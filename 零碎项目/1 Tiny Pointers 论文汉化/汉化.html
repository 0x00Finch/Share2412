<html lang="en">
  <head>
    <title></title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="Document.css" />
    <link rel="stylesheet" type="text/css" href="TextFormat.css" />
    <style>
      /* -- 修复斜体位移用 -- */
      .iDisplace > i {
        position: relative;
        left: -1pt;
      }
      .iDisplace1 {
        position: relative;
        left: -1pt;
      }
      .iDisplace2 {
        position: relative;
        left: -2pt !important;
      }
      /* -- 替代的段落 -- */
      .para {
        margin-top: 1em;
        margin-bottom: 1em;
      }
      /* -- 中文12太大了，改小点 -- */
      .a4_in {
        font-size: 11pt;
      }
      /* -- ul 和 ol 用这个消除与上文的间距 -- */
      .liRNoGap {
        margin-top: 0;
        margin-bottom: 0;
      }
      .tab_6 {
        margin-left: 6pt;
      }
      /* -- 红色 -- */
      .red {
        color: red;
      }
      /* -- 页脚附注 -- */
      .附注 {
        font-size: 9pt;
      }
      .附注居下 {
        position: absolute;
        bottom: 4pt;
      }
    </style>
  </head>

  <body>
    <!-- 页1 -->
    <div class="a4 yahei_font">
      <div class="a4_in">
        <h1 class="center">Tiny Pointers (微指针)</h1>
        <div class="p1_作者">
          <div class="sub">
            <div>Michael A. Bender ∗</div>
            <div>Alex Conway †</div>
            <div>Martn Farach-Colton ‡</div>
          </div>
          <div class="sub sub2">
            <div>William Kuszmaul §</div>
            <div>Guido Tagliavini ¶</div>
          </div>
          <style>
            .p1_作者 {
              display: flex;
              flex-direction: column;
              align-items: center;
              /* 使整个容器的内容居中 */
            }

            .p1_作者 > .sub {
              display: flex;
              justify-content: space-evenly;
              /* 均匀分布元素 */
              width: 500px;
              /* 容器的宽度 */
              text-align: center;
            }

            .p1_作者 > .sub2 {
              width: 400px;
            }
          </style>
        </div>
        <h4 class="center">摘要</h4>
        <div class="indentZh">
          本文介绍了一种新的数据结构对象，我们称之为微指针 (tiny
          pointer)。在许多应用中，传统的 log<i>n</i> 位指针可以被 o(log<i>n</i>)
          位的微指针所替代，代价仅为一个常数因子的时间开销。我们发展了微指针的全面理论，并给出了固定大小微指针
          (fixed-size tiny pointers) 和可变大小微指针 (variable-size tiny
          pointers)
          的最优构造方法。固定大小微指针指的是所有微指针的大小必须相同的设置，而可变大小微指针指的是平均微指针的大小必须较小，但某些微指针可以较大。如果一个微指针引用一个填充到负载因子
          (load factor) 为 1 +
          <i>k</i> 的数组中的元素，那么在固定大小情况下，最优微指针大小是
          Θ(logloglog<i>n</i>
          + log<i>k</i>) 位，而在可变大小情况下，期望的微指针大小是
          Θ(log<i>k</i>) 位。我们的微指针构造还要求我们重新审视与球与箱 (balls
          and bins) 相关的几个经典问题；这些结果可能具有独立的兴趣。
        </div>
        <div class="indentZh">
          通过使用微指针 (tiny
          pointers)，我们重新审视了五个经典的数据结构问题。我们证明了：
          <ul class="no_indent liRNoGap tab_6">
            <li class="iDisplace">
              一个存储 <i>n</i> 个 <i>v</i> 位值的数据结构，针对
              <i>n</i> 个键进行常数时间的修改/查询，可以实现其空间复杂度为
              <i>n</i><i>v</i> + <i>O </i>(<i>n</i> log<sup>(r)</sup><i>n</i>)
              位，其中 r > 0 为任意常数，只要用户为每个键存储一个期望大小为
              <i>O </i>(1) 的微指针，log<sup>(r)</sup><i>n</i> 是 r 次迭代对数。
            </li>
            <li class="iDisplace">
              任何二叉搜索树 (binary search tree)
              都可以通过常数因子的时间开销进行精简，如果我们允许进行
              <i>O </i>(log* <i>n</i>) 时间的修改，它甚至可以在
              <i>O </i>(<i>n</i>) 位内接近最优，即使是旋转树（如伸展树 (splay
              tree) 和红黑树 (red-black tree)）也适用。
            </li>
            <li class="iDisplace">
              任何固定容量的键值字典 (key-value dictionary)
              都可以通过常数时间的开销和 1 + o(1)
              的空间开销变得稳定（即，插入后的项不再移动）。
            </li>
            <li class="iDisplace">
              任何要求统一大小值的键值字典，都可以通过常数时间开销支持任意大小的值，并且对于每个
              j 位值，在空间上增加 log<sup>(r)</sup><i>n</i> + <i>O </i>(log
              <i class="iDisplace2">j</i>) 位的额外开销，其中 r > 0
              为我们选择的任意常数。
            </li>
            <li class="iDisplace">
              给定一个大小为 (1 + ε)<i>n</i> 的外部存储数组 (external-memory
              array) A，其中包含最多 <i>n</i> 个键值对，能够维持一个大小为
              <i>O </i>(<i>n</i> log ε<sup>-1</sup>) 位的内部存储库
              (internal-memory stash)，以便能够在常数时间内计算数组 A
              中任意键值对的位置（且无需 IO 操作）。
            </li>
          </ul>
          这些都是经典且经过广泛研究的问题，在每个情况下，微指针使我们能够将自然的空间低效的解决方案（使用指针）转变为空间高效的解决方案，几乎不需要额外成本。
        </div>
        <div class="p1_页脚">
          <hr />
          <table
            class="tab_16"
            style="position: relative; font-size: 10pt; bottom: 2pt"
          >
            <tr>
              <td>∗ Stony Brook University.</td>
              <td>
                <a href="bender@cs.stonybrook.edu">bender@cs.stonybrook.edu</a>
              </td>
            </tr>
            <tr>
              <td>† VMware Research Group.</td>
              <td><a href="aconway@vmware.com">aconway@vmware.com</a></td>
            </tr>
            <tr>
              <td>‡ Rutgers University.</td>
              <td>
                <a href="martin@farach-colton.com">martin@farach-colton.com</a>
              </td>
            </tr>
            <tr>
              <td>§ Massachusetts Institute of Technology.</td>
              <td><a href="kuszmaul@mit.edu">kuszmaul@mit.edu</a></td>
            </tr>
            <tr>
              <td>¶ Rutgers University.</td>
              <td><a href="guido.tag@rutgers.edu">guido.tag@rutgers.edu</a></td>
            </tr>
          </table>
          <style>
            .p1_页脚 {
              position: absolute;
              bottom: 0;
            }
            .p1_页脚 > table td {
              padding-right: 10pt;
            }
            .p1_页脚 > table a {
              color: black;
            }
          </style>
        </div>
      </div>
      <div
        style="
          position: absolute;
          bottom: 3px;
          width: 100%;
          text-align: center;
          font-size: 9pt;
        "
      >
        汉化：NnWinter @<a href="github.com/NnWinter" style="color: black"
          >github.com/NnWinter</a
        ><br />
        项目:
        <a href="github.com/NnWinter/Share2412" style="color: black"
          >github.com/NnWinter/Share2412</a
        >&gt;零碎项目&gt;1<br />
        如有错误或侵权，请联系修改或删除
      </div>
    </div>
    <!-- 页2 (变量斜体没有加，太耗时，先处理主要内容) -->
    <div class="a4 yahei_font">
      <div class="a4_in">
        <h3>1 引言 (Introduction)</h3>
        <div class="para">
          <div class="">
            存储一个指针需要多少位？如果我们对指针一无所知，只知道它引用的是一个大小为
            <i>n</i> 的数组中的元素，那么指针至少需要 log <i>n</i> 位。
          </div>
          <div class="indentZh">
            然而，对于许多（甚至可能是大多数）指针的使用情况，这个信息论的下限并不适用。正如我们在本文中所看到的，即使是关于指针的少量先验信息（例如，链表中某个节点的前驱）也可以用来突破
            log <i>n</i> 下限。
          </div>
          <div class="indentZh">
            本文介绍了一种通用工具，我们称之为
            <b><i>微指针 (tiny pointer)</i></b
            >，用于压缩指针。在使用指针的场景中，微指针通常可以代替常规指针，从而消除几乎所有的指针空间开销。
          </div>
        </div>
        <div class="para">
          <div>
            <b>什么是微指针 (tiny pointer)？</b>假设有 n
            个或更多的用户（例如，Alice、Bob 等）共享一个大小为 n 的数组
            A。用户可以通过一个函数 Allocate() 请求 A
            中的一个位置，如果有可用的位置，该函数返回一个指针
            p，指向现在专门为该用户保留的位置；用户可以稍后通过调用函数 Free(p)
            来释放该内存位置。每个用户承诺一次最多只分配一个内存位置<sup
              class="red"
              >[1]</sup
            >。例如，如果 Alice 调用 Allocate() 获取指针 p，她必须在再次调用
            Allocate() 之前先调用 Free(p)。
          </div>
          <div class="indentZh">
            指针 p 需要多大？自然的答案是，每个指针使用 logn
            位。然而，考虑到每个指针都有一个不同的所有者，这使得可以将指针压缩到
            o(logn) 位。一个关键的洞察是，同一个指针 p
            对不同的用户可能意味着不同的内容，通过以下方案实现：用户 k 可以调用
            Allocate(k) 来获取一个微指针 (tiny pointer)
            p；他们可以通过计算一个函数 Dereference(kp) 来解引用微指针
            p，该函数的值仅依赖于 k、p 和随机位；他们可以通过调用函数 Free(kp)
            来释放微指针 p。
          </div>
          <div class="indentZh">
            微指针之所以不受信息论下界 log n 位的限制，是因为 k 和 p
            一起编码了分配的位置，而不是仅仅编码
            p。因此，这个方案提供了一种机制，利用已经存在的关于指针的信息（即，指针的所有者是谁）将指针压缩到
            o(logn) 位大小。
          </div>
          <div class="">
            我们将函数 Allocate(k)/Dereference(kp)/Free(kp) 的算法，以及数组 A
            和任何相关的元数据 M，统称为<b>解引用表 (dereference table)</b
            >。我们通常将用户（即微指针 (tiny pointer) 的所有者）称为<b
              >键 (keys)</b
            >，将存储在微指针所指向的分配位置的数据称为<b>值 (values)</b
            >。一个解引用表，如果能够在一个 nb 位的数组中存储 b 位值（并使用
            O(n) 位的元数据），并且能够在一次操作中存储 (1-δ)n
            个值，则称其支持<b>负载因子 (load factor)</b> 1-δ。
          </div>
          <div class="indentZh">
            理想的解引用表应同时支持 δ=o(1) 的负载因子、o(logn)
            大小的微指针，并且具有常数时间的操作。正如我们将要讨论的那样，我们证明了最佳可实现的负载因子
            1-δ 和最佳可实现的微指针大小 s
            之间的权衡曲线。在这条权衡曲线上构造最优的解引用表是本文的核心问题之一。
          </div>
          <div class="para">
            <b
              >使用微指针 (tiny pointers)
              来获得微小数据结构。除了使用微指针构造解引用表 (dereference
              tables)
              之外，我们还展示了这些解引用表可以用于为多个经典问题提供改进的解决方案：</b
            >
            <ul class="liRNoGap">
              <li>
                一个存储 n 个 v 位值的数据结构，针对 n
                个键进行常数时间的修改和查询，可以实现其空间复杂度为 nv + O(n
                log<sup>(r)</sup> n) 位，其中 r > 0
                为任意常数，只要用户为每个键存储一个期望大小为 O(1)
                的微指针，在这里，log<sup>(r)</sup> n 是 r 次迭代对数。<sup class="red"
                  >[2]</sup
                >
              </li>
              <li>
                存储 n 个可排序键的 n 个节点的任何二叉搜索树 (binary search
                tree) 都可以通过常数时间的开销进行精简，并且可以通过 O(log* n)
                时间的修改在 O(n) 位内接近最优。这甚至适用于伸展树 (splay tree)
                等基于旋转的树，伸展树被猜测是动态最优的。
              </li>
              <li>
                存储 v 位值的任何固定容量键值字典 (key-value dictionary)
                都可以通过常数时间的开销变得稳定（即，插入后的项不再移动），并且每个值的附加空间开销为
                O(logv) 位。
              </li>
              <li>
                任何要求统一大小值的键值字典，都可以通过常数时间的开销支持任意大小的值，并且对于每个
                j 位值，在空间上增加 log<sup>(r)</sup> n + O(logj) 位的额外开销，其中 r > 0
                为我们选择的任意常数。
              </li>
            </ul>
          </div>
        </div>
        <div class="p2_页脚 附注 附注居下">
          <hr />
          <div class="indentZh">
            <sup>[1]</sup> 用户 k
            可以通过为每个分配创建一个唯一标签来请求多个位置。在这种情况下，我们将分配的用户视为
            k 的拼接，因此用户 k 可以拥有多个分配，而不违反唯一性要求。
          </div>
          <div class="indentZh">
            <sup>[2]</sup> 即，log<sup>(1)</sup> n := logn 且 log<sup>(i+1)</sup> n := loglog<sup>(i)</sup> n。
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
